static FILE *testFile = NULL;
static char initialTestFileName[256];

void
openTestFile (const char *fileName)
{
  if (fileName == NULL || fileName[0] == 0)
    return;
    strcpy (initialTestFileName, fileName);
strcat(initialTestFileName, ".test");
  testFile = fopen (initialTestFileName, "wb");
  if (testFile == NULL)
    {
      fprintf (stderr, "Cannot open test file %s\n", fileName);
      testFile = stderr;
    }
}

void
testPrint (const char *format, ...)
{
#ifndef __SYMBIAN32__
  va_list argp;
  if (format == NULL)
    return;
  if (testFile == NULL && initialTestFileName[0] != 0)
    testFile = fopen (initialTestFileName, "wb");
  if (testFile == NULL)
    testFile = stderr;
  va_start (argp, format);
  vfprintf (testFile, format, argp);
  fprintf (testFile, "\n");
  va_end (argp);
#endif
}

void
closeTestFile ()
{
  if (testFile != NULL && testFile != stderr)
    fclose (testFile);
  testFile = NULL;
}

static const char *internalOpcodeNames[CTO_None] = {
"none",
"capitalRule",
"beginCapitalRule",
"endCapitalRule",
"firstWordCapsRule",
"lastWordCapsBeforeRule",
"lastWordCapsAfterRule",
"letterRule",
"numberRule",
"firstWordItalRule",
"lastWordItalBeforeRule",
"lastWordItalAfterRule",
"firstLetterItalRule",
"lastLetterItalRule",
"singleLetterItalRule",
"italWordRule",
"firstWordBoldRule",
"lastWordBoldBeforeRule",
"lastWordBoldAfterRule",
"firstLetterBoldRule",
"lastLetterBoldRule",
"singleLetterBoldRule",
"boldWordRule",
"firstWordUnderRule",
"lastWordUnderBeforeRule",
"lastWordUnderAfterRule",
"firstLetterUnderRule",
"lastLetterUnderRule",
"singleLetterUnderRule",
"underWordRule",
"begCompRule",
"compBegEmph1Rule",
"compEndEmph1Rule",
"compBegEmph2Rule",
"compEndEmrh2Rule",
"compBegEmph3Rule",
"compEndEmph3Rule",
"compCapSignRule",
"compBegCapsRule",
"compEndCapsRule",
"endCompRule",
"capsNoContRule"
};

const char *
showOpcodeName (TranslationTableOpcode opcode)
{
  if (opcode < 0 || opcode >= CTO_All)
    {
      sprintf (scratchBuf, "%d", opcode);
      return scratchBuf;
    }
if (opcode < CTO_None)
return findOpcodeName(opcode);
  return internalOpcodeNames[opcode - CTO_None];
}

char *
showQuotedString (widechar const *chars, int length)
{
char* strBuf = showString(chars, length);
size_t len = strlen(strBuf);
if (len >= 2)
{
strBuf[0] = '\"';
strBuf[len-1] = '\"';
}
return strBuf;
}

char*
showSwapDots(widechar* dots, int length)
{
static char strBuf[MAXSTRING];
char* strPtr = &strBuf[0];
int len, i = 0;
while (i < length)
{
len = dots[i] - 1;
strPtr += sprintf(strPtr, "%s%s",
((i > 0) ? "," : ""),
showDots(&dots[i+1], len));
i += len+1;
}
*strPtr = '\0';
return &strBuf[0];
}

char*
showEmphasis(widechar emphasis)
{
static char strBuf[MAXSTRING];
char* strPtr = &strBuf[0];
if (emphasis & italic)
*strPtr++ = 'i';
if (emphasis & bold)
*strPtr++ = 'b';
if (emphasis & underline)
*strPtr++ = 'u';
if (emphasis & computer_braille)
*strPtr++ = 'c';
*strPtr = '\0';
return &strBuf[0];
}

char*
showPassRange(widechar *passInstructions, int* passIC)
{
static char strBuf[MAXSTRING];
char* strPtr = &strBuf[0];
widechar num1, num2;
num1 = passInstructions[*passIC];
(*passIC)++;
num2 = passInstructions[*passIC];
(*passIC)++;
strPtr += sprintf(strPtr, ",%d,%d", num1, num2);
return &strBuf[0];
}

char*
showPassScriptToken(widechar *passInstructions, int* passIC, int* testPart)
{
static char strBuf[MAXSTRING];
char* strPtr = &strBuf[0];
pass_Codes code = (pass_Codes) passInstructions[*passIC];
(*passIC)++;
switch (code)
{
case pass_first: //='`',
strPtr += sprintf(strPtr, " first");
break;
case pass_last: //='~',
strPtr += sprintf(strPtr, " last");
break;
case pass_lookback: //='_',
strPtr += sprintf(strPtr, " back(%d)", passInstructions[*passIC]);
(*passIC)++;
break;
case pass_string: //='\"',
{
int len = passInstructions[*passIC];
(*passIC)++;
strPtr += sprintf(strPtr, " %s",
showQuotedString(&passInstructions[*passIC], len));
(*passIC) += len;
break;
}
case pass_dots: //='@',
{
int len = passInstructions[*passIC];
(*passIC)++;
strPtr += sprintf(strPtr, " @%s",
showDots(&passInstructions[*passIC], len));
(*passIC) += len;
break;
}
case pass_omit: //='?',
strPtr += sprintf(strPtr, " repomit");
break;
case pass_startReplace: //='[',
strPtr += sprintf(strPtr, " [");
break;
case pass_endReplace: //=']',
strPtr += sprintf(strPtr, " ]");
break;
case pass_variable: //='#',
strPtr += sprintf(strPtr, " <variable>");
break;
case pass_not: //='!',
strPtr += sprintf(strPtr, " !");
break;
case pass_search: //='/',
strPtr += sprintf(strPtr, " find");
break;
case pass_attributes: //='$',
{
TranslationTableCharacterAttributes attributes = (((TranslationTableCharacterAttributes) passInstructions[*passIC]) << 16) | passInstructions[(*passIC)+1];
(*passIC) += 2;
strPtr += sprintf(strPtr, " attr(%s%s)",
showAttributes(attributes), showPassRange(passInstructions, passIC));
break;
}
case pass_groupstart: //='{',
{
const struct RuleName *nameRule = ruleNames;
TranslationTableOffset offset = (((TranslationTableOffset) passInstructions[*passIC]) << 16) | passInstructions[(*passIC)+1];
(*passIC) += 2;
while (nameRule)
{
if (offset == nameRule->ruleOffset)
break;
nameRule = nameRule->next;
}
strPtr += sprintf(strPtr, " {(%s)",
(nameRule ? showQuotedString(nameRule->name, nameRule->length) : "?"));
break;
}
case pass_groupend: //='}',
{
const struct RuleName *nameRule = ruleNames;
TranslationTableOffset offset = (((TranslationTableOffset) passInstructions[*passIC]) << 16) | passInstructions[(*passIC)+1];
(*passIC) += 2;
while (nameRule)
{
if (offset == nameRule->ruleOffset)
break;
nameRule = nameRule->next;
}
strPtr += sprintf(strPtr, " }(%s)",
(nameRule ? showQuotedString(nameRule->name, nameRule->length) : "?"));
break;
}
case pass_groupreplace: //=';',
{
const struct RuleName *nameRule = ruleNames;
TranslationTableOffset offset = (((TranslationTableOffset) passInstructions[*passIC]) << 16) | passInstructions[(*passIC)+1];
(*passIC) += 2;
while (nameRule)
{
if (offset == nameRule->ruleOffset)
break;
nameRule = nameRule->next;
}
strPtr += sprintf(strPtr, " ;(%s)",
(nameRule ? showQuotedString(nameRule->name, nameRule->length) : "?"));
break;
}
case pass_swap: //='%',
{
const struct RuleName *nameRule = ruleNames;
TranslationTableOffset offset = (((TranslationTableOffset) passInstructions[*passIC]) << 16) | passInstructions[(*passIC)+1];
(*passIC) += 2;
while (nameRule)
{
if (offset == nameRule->ruleOffset)
break;
nameRule = nameRule->next;
}
if (*testPart)
{
strPtr += sprintf(strPtr, " swap(%s%s)",
(nameRule ? showQuotedString(nameRule->name, nameRule->length) : "?"),
showPassRange(passInstructions, passIC));
} else {
strPtr += sprintf(strPtr, " swap(%s)",
(nameRule ? showQuotedString(nameRule->name, nameRule->length) : "?"));
}
break;
}
case pass_hyphen: //='-',
{
widechar var = passInstructions[*passIC];
widechar val = 1; //passInstructions[(*passIC)+1];
(*passIC) += 1;
strPtr += sprintf(strPtr, " var(%d)-%d", var, val);
break;
}
case pass_until: //='.',
strPtr += sprintf(strPtr, " <until>");
break;
case pass_eq: //='=',
{
widechar var = passInstructions[*passIC];
widechar val = passInstructions[(*passIC)+1];
(*passIC) += 2;
strPtr += sprintf(strPtr, " var(%d)=%d", var, val);
break;
}
case pass_lt: //='<',
{
widechar var = passInstructions[*passIC];
widechar val = passInstructions[(*passIC)+1];
(*passIC) += 2;
strPtr += sprintf(strPtr, " var(%d)<%d", var, val);
break;
}
case pass_gt: //='>',
{
widechar var = passInstructions[*passIC];
widechar val = passInstructions[(*passIC)+1];
(*passIC) += 2;
strPtr += sprintf(strPtr, " var(%d)>%d", var, val);
break;
}
case pass_endTest: //=32,
strPtr += sprintf(strPtr, " <then>");
*testPart = 0;
break;
case pass_plus: //='+',
{
widechar var = passInstructions[*passIC];
widechar val = 1; //passInstructions[(*passIC)+1];
(*passIC) += 1;
strPtr += sprintf(strPtr, " var(%d)+%d", var, val);
break;
}
case pass_copy: //='*',
strPtr += sprintf(strPtr, " repcopy");
break;
case pass_leftParen: //='(',
strPtr += sprintf(strPtr, " <(>");
break;
case pass_rightParen: //=')',
strPtr += sprintf(strPtr, " <)>");
break;
case pass_comma: //=',',
strPtr += sprintf(strPtr, " <,>");
break;
case pass_hypothesis: //=':',
strPtr += sprintf(strPtr, " hypothesis");
break;
case pass_lteq: //=130,
{
widechar var = passInstructions[*passIC];
widechar val = passInstructions[(*passIC)+1];
(*passIC) += 2;
strPtr += sprintf(strPtr, " var(%d)<=%d", var, val);
break;
}
case pass_gteq: //=131,
{
widechar var = passInstructions[*passIC];
widechar val = passInstructions[(*passIC)+1];
(*passIC) += 2;
strPtr += sprintf(strPtr, " var(%d)>=%d", var, val);
break;
}
case pass_invalidToken: //=132,
strPtr += sprintf(strPtr, " <invalid>");
break;
case pass_noteq: //=133,
{
widechar var = passInstructions[*passIC];
widechar val = passInstructions[(*passIC)+1];
(*passIC) += 2;
strPtr += sprintf(strPtr, " var(%d)!=%d", var, val);
break;
}
case pass_and: //=134,
strPtr += sprintf(strPtr, " &&");
break;
case pass_or: // =135,
strPtr += sprintf(strPtr, " ||");
break;
case pass_nameFound: //=136,
strPtr += sprintf(strPtr, " <nameFound>");
break;
case pass_numberFound: //=137,
strPtr += sprintf(strPtr, " <numberFound");
break;
case pass_boolean: //=138,
strPtr += sprintf(strPtr, " <bool>");
break;
case pass_class: //=139,
strPtr += sprintf(strPtr, " <class>");
break;
case pass_define: //=140,
strPtr += sprintf(strPtr, " <def>");
break;
case pass_emphasis: //=141,
strPtr += sprintf(strPtr, " emph(%s)",
showEmphasis(passInstructions[*passIC]));
(*passIC)++;
break;
case pass_group: //=142,
strPtr += sprintf(strPtr, " group(");
break;
case pass_mark: //=143,
strPtr += sprintf(strPtr, " <mark>");
break;
//case pass_repGroup: //=143,
case pass_script: //=144,
strPtr += sprintf(strPtr, " <script>");
break;
case pass_noMoreTokens: //=145,
strPtr += sprintf(strPtr, " <nomoretokens>");
break;
case pass_replace: //=146,
strPtr += sprintf(strPtr, " <rep>");
break;
case pass_if: //=147,
strPtr += sprintf(strPtr, " <if>");
break;
case pass_then: //=148,
strPtr += sprintf(strPtr, " <then>");
break;
default:
strPtr += sprintf(strPtr, " <unknown>");
}
return &strBuf[0];
}

char*
showRule(TranslationTableOffset ruleOffset)
{
static char strRuleBuf[10*MAXSTRING];
char* strPtr = &strRuleBuf[0];
TranslationTableRule* rule;
if (ruleOffset == 0)
return "(NULL)";
rule = (TranslationTableRule *) & table->ruleArea[ruleOffset];
if (!rule)
return "(NULL)";
strPtr += sprintf(strPtr, "%s ",
showOpcodeName(rule->opcode));

if (rule->opcode >= CTO_Context && rule->opcode <= CTO_Pass4)
{
widechar *passInstructions = &rule->charsdots[rule->charslen];
int passIC = 0;
int testPart = 1;
strPtr += sprintf(strPtr, "before(%d) after(%d) ", rule->before, rule->after);
if (rule->charslen)
if (rule->opcode == CTO_Context || rule->opcode == CTO_Correct)
strPtr += sprintf(strPtr, "<%s> ",
showQuotedString(rule->charsdots, rule->charslen));
else
strPtr += sprintf(strPtr, "<@%s> ",
showDots(rule->charsdots, rule->charslen));
while (passIC < rule->dotslen)
strPtr += sprintf(strPtr, "%s", showPassScriptToken(passInstructions, &passIC, &testPart));
} else
{
if (rule->before)
strPtr += sprintf(strPtr, "beforeAttr(%s) ",
showAttributes(rule->before));
if (rule->after)
strPtr += sprintf(strPtr, "afterAttr(%s) ",
showAttributes(rule->after));

if (rule->opcode == CTO_MultInd)
{
int i;
strPtr += sprintf(strPtr, "%s",
((rule->dotslen > 0) ? showDots(&rule->charsdots[rule->charslen], rule->dotslen) : ""));
for (i = 0; i < rule->charslen; i++)
strPtr += sprintf(strPtr, " %s", showOpcodeName(rule->charsdots[i]));
} else
{
if (rule->opcode == CTO_SwapDd)
{
strPtr += sprintf(strPtr, "%s ",
((rule->charslen > 0) ? showSwapDots(rule->charsdots, rule->charslen) : ""));
} else {
strPtr += sprintf(strPtr, "%s ",
((rule->charslen > 0) ? showQuotedString(rule->charsdots, rule->charslen) : ""));
}

if (rule->opcode == CTO_SwapCd || rule->opcode == CTO_SwapDd)
{
strPtr += sprintf(strPtr, "%s",
((rule->dotslen > 0) ? showSwapDots(&rule->charsdots[rule->charslen], rule->dotslen) : ""));
} else
if (rule->opcode == CTO_Grouping && rule->dotslen == 2)
{
strPtr += sprintf(strPtr, "%s,%s",
showDots(&rule->charsdots[rule->charslen], 1), showDots(&rule->charsdots[rule->charslen+1], 1));
} else
if (rule->opcode == CTO_NoBreak || rule->opcode == CTO_Replace)
{
strPtr += sprintf(strPtr, "%s",
((rule->dotslen > 0) ? showQuotedString(&rule->charsdots[rule->charslen], rule->dotslen) : ""));
} else {
strPtr += sprintf(strPtr, "%s",
((rule->dotslen > 0) ? showDots(&rule->charsdots[rule->charslen], rule->dotslen) : ""));
}
}
}
*strPtr = '\0';
return &strRuleBuf[0];
}

char*
showPassRules(TranslationTableOffset offset)
{
TranslationTableRule *currentRule;
while (offset)
{
testPrint(showRule(offset));
currentRule = (TranslationTableRule *) & table->ruleArea[offset];
offset = currentRule->charsnext;
}
}

char*
showCharacter(TranslationTableCharacter* character, int m, int details)
{
static char strCharBuf[50*MAXSTRING];
char* strPtr = &strCharBuf[0];
if (!character)
return "(NULL)";
strPtr += sprintf(strPtr, "%s ",
showAttributes(character->attributes));
if (m == 0)
{
strPtr += sprintf(strPtr, "%s ",
showQuotedString(&character->realchar, 1));
if (character->uppercase != character->realchar)
strPtr += sprintf(strPtr, "ucase(%s) ",
showQuotedString(&character->uppercase, 1));
if (character->lowercase != character->realchar)
strPtr += sprintf(strPtr, "lcase(%s) ",
showQuotedString(&character->lowercase, 1));
} else {
strPtr += sprintf(strPtr, "%s ",
showDots(&character->realchar, 1));
if (character->uppercase != character->realchar)
strPtr += sprintf(strPtr, "ucase(%s) ",
showDots(&character->uppercase, 1));
if (character->lowercase != character->realchar)
strPtr += sprintf(strPtr, "lcase(%s) ",
showDots(&character->lowercase, 1));
}
if (character->definitionRule)
strPtr += sprintf(strPtr, "/ %s", showRule(character->definitionRule));

if (details)
{
TranslationTableOffset currentOffset;
TranslationTableRule *currentRule;
int shownOther = 0;
currentOffset = character->otherRules;
while (currentOffset)
{
currentRule = (TranslationTableRule *) & table->ruleArea[currentOffset];
if (character->definitionRule != currentOffset)
strPtr += sprintf(strPtr, " | %s", showRule(currentOffset));
else
if (shownOther || (m == 0 && currentRule->charsnext) || (m == 1 && currentRule->dotsnext))
strPtr += sprintf(strPtr, " |\\");
shownOther = 1;
currentOffset = ((m == 0) ? currentRule->charsnext : currentRule->dotsnext);
}
}
*strPtr = '\0';
return &strCharBuf[0];
}

char*
showCharOrDots(CharOrDots* cdPtr, int m)
{
static char strBuf[50*MAXSTRING];
char* strPtr = &strBuf[0];
TranslationTableCharacter* character;
if (!cdPtr)
return "(NULL)";
if (m == 0)
{
strPtr += sprintf(strPtr, "%s ",
showQuotedString(&cdPtr->lookFor, 1));
strPtr += sprintf(strPtr, "%s",
showDots(&cdPtr->found, 1));
character = compile_findCharOrDots(cdPtr->lookFor, 0);
if (character)
strPtr += sprintf(strPtr, " ; character: %s",
showCharacter(character, 0, 0));
character = compile_findCharOrDots(cdPtr->found, 1);
if (character)
strPtr += sprintf(strPtr, " ; dots: %s",
showCharacter(character, 1, 0));
} else {
strPtr += sprintf(strPtr, "%s ",
showDots(&cdPtr->lookFor, 1));
strPtr += sprintf(strPtr, "%s",
showQuotedString(&cdPtr->found, 1));
character = compile_findCharOrDots(cdPtr->lookFor, 1);
if (character)
strPtr += sprintf(strPtr, " ; dots: %s",
showCharacter(character, 1, 0));
character = compile_findCharOrDots(cdPtr->found, 0);
if (character)
strPtr += sprintf(strPtr, " ; character: %s",
showCharacter(character, 0, 0));
}
*strPtr = '\0';
return &strBuf[0];
}

void testingTableFile (const char *fileName)
{
int i;
TranslationTableOffset bucket;
TranslationTableCharacter *character;
CharOrDots *cdPtr;
TranslationTableRule* rule;

openTestFile(fileName);

if (table->capsNoCont)
testPrint(showRule(table->capsNoCont));
testPrint("numPasses: %d", table->numPasses);
testPrint("corrections: %d", table->corrections);
testPrint("syllables: %d", table->syllables);
if (table->noBreak)
testPrint(showRule(table->noBreak));
if (table->undefined)
testPrint(showRule(table->undefined));
if (table->letterSign)
testPrint(showRule(table->letterSign));
if (table->numberSign)
testPrint(showRule(table->numberSign));
if (table->firstWordItal)
testPrint(showRule(table->firstWordItal));
if (table->lastWordItalBefore)
testPrint(showRule(table->lastWordItalBefore));
if (table->lastWordItalAfter)
testPrint(showRule(table->lastWordItalAfter));
if (table->firstLetterItal)
testPrint(showRule(table->firstLetterItal));
if (table->lastLetterItal)
testPrint(showRule(table->lastLetterItal));
if (table->singleLetterItal)
testPrint(showRule(table->singleLetterItal));
if (table->italWord)
testPrint(showRule(table->italWord));
if (table->lenItalPhrase)
testPrint("lenItalPhrase %d", table->lenItalPhrase);
if (table->firstWordBold)
testPrint(showRule(table->firstWordBold));
if (table->lastWordBoldBefore)
testPrint(showRule(table->lastWordBoldBefore));
if (table->lastWordBoldAfter)
testPrint(showRule(table->lastWordBoldAfter));
if (table->firstLetterBold)
testPrint(showRule(table->firstLetterBold));
if (table->lastLetterBold)
testPrint(showRule(table->lastLetterBold));
if (table->singleLetterBold)
testPrint(showRule(table->singleLetterBold));
if (table->boldWord)
testPrint(showRule(table->boldWord));
if (table->lenBoldPhrase)
testPrint("lenBoldPhrase %d", table->lenBoldPhrase);
if (table->firstWordUnder)
testPrint(showRule(table->firstWordUnder));
if (table->lastWordUnderBefore)
testPrint(showRule(table->lastWordUnderBefore));
if (table->lastWordUnderAfter)
testPrint(showRule(table->lastWordUnderAfter));
if (table->firstLetterUnder)
testPrint(showRule(table->firstLetterUnder));
if (table->lastLetterUnder)
testPrint(showRule(table->lastLetterUnder));
if (table->singleLetterUnder)
testPrint(showRule(table->singleLetterUnder));
if (table->underWord)
testPrint(showRule(table->underWord));
if (table->lenUnderPhrase)
testPrint("lenUnderPhrase %d", table->lenUnderPhrase);
if (table->firstWordCaps)
testPrint(showRule(table->firstWordCaps));
if (table->lastWordCapsBefore)
testPrint(showRule(table->lastWordCapsBefore));
if (table->lastWordCapsAfter)
testPrint(showRule(table->lastWordCapsAfter));
if (table->beginCapitalSign)
testPrint(showRule(table->beginCapitalSign));
if (table->endCapitalSign)
testPrint(showRule(table->endCapitalSign));
if (table->capitalSign)
testPrint(showRule(table->capitalSign));
if (table->CapsWord)
testPrint(showRule(table->CapsWord));
if (table->lenCapsPhrase)
testPrint("lenCapsPhrase %d", table->lenCapsPhrase);
if (table->lenBeginCaps)
testPrint("lenBeginCaps %d", table->lenBeginCaps);
if (table->begComp)
testPrint(showRule(table->begComp));
if (table->endComp)
testPrint(showRule(table->endComp));
if (table->noLetsignBeforeCount)
testPrint("noLetsignBefore %s", showQuotedString(table->noLetsignBefore, table->noLetsignBeforeCount));
if (table->noLetsignCount)
testPrint("noLetsign %s", showQuotedString(table->noLetsign, table->noLetsignCount));
if (table->noLetsignAfterCount)
testPrint("noLetsignAfter %s", showQuotedString(table->noLetsignAfter, table->noLetsignAfterCount));

if (characterClasses) {
struct CharacterClass *class = characterClasses;
testPrint("**character classes:");
while (class) {
testPrint("name: %s, attributes: %s", 
showQuotedString(class->name, class->length),
showAttributes(class->attribute));
class = class->next;
}
}

if (ruleNames) {
TranslationTableRule* rule;
struct RuleName *ruleName = ruleNames;
testPrint("**rule names:");
while (ruleName) {
rule = (TranslationTableRule *) & table->ruleArea[ruleName->ruleOffset];
testPrint("name: %s; %s",
showQuotedString(ruleName->name, ruleName->length),
showRule(ruleName->ruleOffset));
ruleName = ruleName->next;
}
}

if (passNames)
{
char name[200];
int i;
struct PassName * passName = passNames;
testPrint("**pass names:");
while (passName)
{
for (i = 0; i < passName->length-1; i++)
name[i] = (char) passName->name[i];
name[passName->length-1] = '\0';
testPrint("%s ; name: %s, varNum: %d",
showOpcodeName(passName->name[passName->length-1]),
name, passName->varnum);
passName = passName->next;
}
}

testPrint("**characters:");
for (i = 0; i < HASHNUM; i++)
{
bucket = table->characters[i];
  while (bucket)
    {
      character = (TranslationTableCharacter *) & table->ruleArea[bucket];
testPrint(showCharacter(character, 0, 1));
      bucket = character->next;
    }
}

testPrint("**dots:");
for (i = 0; i < HASHNUM; i++)
{
bucket = table->dots[i];
  while (bucket)
    {
      character = (TranslationTableCharacter *) & table->ruleArea[bucket];
testPrint(showCharacter(character, 1, 1));
      bucket = character->next;
    }
}

testPrint("**Dots for characters:");
for (i = 0; i < HASHNUM; i++)
{
bucket = table->charToDots[i];
  while (bucket)
    {
      cdPtr = (CharOrDots *) & table->ruleArea[bucket];
testPrint(showCharOrDots(cdPtr, 0));
      bucket = cdPtr->next;
    }
}

testPrint("**characters from dots");
for (i = 0; i < HASHNUM; i++)
{
bucket = table->dotsToChar[i];
  while (bucket)
    {
      cdPtr = (CharOrDots *) & table->ruleArea[bucket];
testPrint(showCharOrDots(cdPtr, 1));
      bucket = cdPtr->next;
    }
}

testPrint("**computer dots patterns:");
for (i = 0; i < 256; i++)
if (table->compdotsPattern[i])
testPrint(showRule(table->compdotsPattern[i]));

if (table->attribOrSwapRules[0])
{
testPrint("**correct rules:");
showPassRules(table->attribOrSwapRules[0]);
}
if (table->attribOrSwapRules[1])
{
testPrint("**context rules:");
showPassRules(table->attribOrSwapRules[1]);
}
if (table->attribOrSwapRules[2])
{
testPrint("**pass2 rules:");
showPassRules(table->attribOrSwapRules[2]);
}
if (table->attribOrSwapRules[3])
{
testPrint("**pass3 rules:");
showPassRules(table->attribOrSwapRules[3]);
}
if (table->attribOrSwapRules[4])
{
testPrint("**pass4 rules:");
showPassRules(table->attribOrSwapRules[4]);
}

testPrint("**forward rules:");
for (i = 0; i < HASHNUM; i++)
{
bucket = table->forRules[i];
  while (bucket)
    {
testPrint(showRule(bucket));
      rule = (TranslationTableRule *) & table->ruleArea[bucket];
      bucket = rule->charsnext;
    }
}

testPrint("**backward rules:");
for (i = 0; i < HASHNUM; i++)
{
bucket = table->backRules[i];
  while (bucket)
    {
testPrint(showRule(bucket));
      rule = (TranslationTableRule *) & table->ruleArea[bucket];
      bucket = rule->dotsnext;
    }
}

closeTestFile();
}
